var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/logger_text.ts
import c from "ansi-colors";

// src/logger.ts
import EventEmitter from "events";

// src/log_consts.ts
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["OFF"] = 0] = "OFF";
  LogLevel2[LogLevel2["ERROR"] = 1] = "ERROR";
  LogLevel2[LogLevel2["SOFT_FAIL"] = 2] = "SOFT_FAIL";
  LogLevel2[LogLevel2["WARNING"] = 3] = "WARNING";
  LogLevel2[LogLevel2["INFO"] = 4] = "INFO";
  LogLevel2[LogLevel2["DEBUG"] = 5] = "DEBUG";
  LogLevel2[LogLevel2["PERF"] = 6] = "PERF";
  return LogLevel2;
})(LogLevel || {});
var PREFIX_DELIMITER = ":";
var LEVELS = LogLevel;
var LEVEL_TO_STRING = Object.keys(LogLevel).filter((x) => Number.isNaN(+x));

// src/logger.ts
var Logger = class extends EventEmitter {
  constructor(options) {
    super();
    this.options = options;
  }
  setOptions(options) {
    this.options = { ...this.options, ...options };
  }
  getOptions() {
    return this.options;
  }
  _outputWithConsole(level, line) {
    switch (level) {
      case 1 /* ERROR */:
        console.error(line);
        break;
      case 3 /* WARNING */:
        console.warn(line);
        break;
      case 5 /* DEBUG */:
        console.debug(line);
        break;
      default:
        console.log(line);
    }
  }
  _log(level, message, data, exception, opts = {}) {
    throw new Error("log() method must be implemented!");
  }
  log(level, message, ...args) {
    const line = this._log(level, message, ...args);
    this.emit("line", line);
  }
};
__name(Logger, "Logger");

// src/logger_text.ts
var SHORTEN_LEVELS = {
  SOFT_FAIL: "SFAIL",
  WARNING: "WARN"
};
var LEVEL_TO_COLOR = {
  [1 /* ERROR */]: "red",
  [2 /* SOFT_FAIL */]: "red",
  [3 /* WARNING */]: "yellow",
  [4 /* INFO */]: "green",
  [5 /* DEBUG */]: "blue",
  [6 /* PERF */]: "magenta"
};
var SHORTENED_LOG_LEVELS = LEVEL_TO_STRING.map((level) => SHORTEN_LEVELS[level] || level);
var MAX_LEVEL_LENGTH_SPACES = Math.max(...SHORTENED_LOG_LEVELS.map((l) => l.length));
var getLevelIndent = /* @__PURE__ */ __name((level) => {
  let spaces = "";
  for (let i = 0; i < MAX_LEVEL_LENGTH_SPACES - level.length; i++)
    spaces += " ";
  return spaces;
}, "getLevelIndent");
var DEFAULT_OPTIONS = {
  skipTime: true
};
var LoggerText = class extends Logger {
  constructor(options = {}) {
    super({ ...DEFAULT_OPTIONS, ...options });
  }
  _log(level, message, data, exception, opts = {}) {
    let { prefix, suffix } = opts;
    let maybeDate = "";
    if (!this.options.skipTime) {
      maybeDate = `${new Date().toISOString().replace("Z", "").replace("T", " ")} `;
    }
    const errStack = exception ? this._parseException(exception) : "";
    const color = LEVEL_TO_COLOR[level];
    const levelStr = SHORTENED_LOG_LEVELS[level];
    const levelIndent = getLevelIndent(levelStr);
    const dataStr = !data ? "" : ` ${JSON.stringify(data)}`;
    prefix = prefix ? ` ${prefix}${PREFIX_DELIMITER}` : "";
    suffix = suffix ? ` ${suffix}` : "";
    const line = `${c.gray(maybeDate)}${c[color](levelStr)}${levelIndent}${c.yellow(prefix)} ${message || ""}${c.gray(dataStr)}${c.yellow(suffix)}${errStack}`;
    this._outputWithConsole(level, line);
    return line;
  }
  _parseException(exception) {
    let errStack = "";
    const errDetails = [];
    if (exception.type)
      errDetails.push(`type=${exception.type}`);
    if (exception.details) {
      Object.entries(exception.details).map(([key, val]) => errDetails.push(`${key}=${val}`));
    }
    const errorString = exception.stack || exception.reason || exception.toString();
    const errorLines = errorString.split("\n");
    if (errDetails.length)
      errorLines[0] += c.gray(`(details: ${errDetails.join(", ")})`);
    errStack = errorLines.map((line) => `  ${line}`).join("\n");
    errStack = `
${errStack}`;
    return errStack;
  }
};
__name(LoggerText, "LoggerText");

// src/log_helpers.ts
import { ENV_VARS } from "@apify/consts";
function truncate(str, maxLength, suffix = "...[truncated]") {
  maxLength = Math.floor(maxLength);
  if (suffix.length > maxLength) {
    throw new Error("suffix string cannot be longer than maxLength");
  }
  if (typeof str === "string" && str.length > maxLength) {
    str = str.substr(0, maxLength - suffix.length) + suffix;
  }
  return str;
}
__name(truncate, "truncate");
function getLevelFromEnv() {
  const envVar = process.env[ENV_VARS.LOG_LEVEL];
  if (!envVar)
    return 4 /* INFO */;
  if (Number.isFinite(+envVar))
    return +envVar;
  if (LogLevel[envVar])
    return LogLevel[envVar];
  return +envVar;
}
__name(getLevelFromEnv, "getLevelFromEnv");
function limitDepth(record, depth, maxStringLength) {
  if (typeof record === "string") {
    return maxStringLength && record.length > maxStringLength ? truncate(record, maxStringLength) : record;
  }
  if (["number", "boolean"].includes(typeof record) || record == null || record instanceof Date) {
    return record;
  }
  if (record instanceof Error) {
    const { name, message, stack, ...rest } = record;
    record = { name, message, stack, ...rest };
  }
  const nextCall = /* @__PURE__ */ __name((rec) => limitDepth(rec, depth - 1, maxStringLength), "nextCall");
  if (Array.isArray(record)) {
    return depth ? record.map(nextCall) : "[array]";
  }
  if (typeof record === "object" && record !== null) {
    const mapObject = /* @__PURE__ */ __name((obj) => {
      const res = {};
      Object.keys(obj).forEach((key) => {
        res[key] = nextCall(obj[key]);
      });
      return res;
    }, "mapObject");
    return depth ? mapObject(record) : "[object]";
  }
  if (typeof record === "function") {
    return "[function]";
  }
  console.log(`WARNING: Object cannot be logged: ${record}`);
  return void 0;
}
__name(limitDepth, "limitDepth");

// src/log.ts
var getDefaultOptions = /* @__PURE__ */ __name(() => ({
  level: getLevelFromEnv(),
  maxDepth: 4,
  maxStringLength: 2e3,
  prefix: null,
  suffix: null,
  logger: new LoggerText(),
  data: {}
}), "getDefaultOptions");
var Log = class {
  constructor(options = {}) {
    this.LEVELS = LogLevel;
    this.warningsOnceLogged = /* @__PURE__ */ new Set();
    this.options = { ...getDefaultOptions(), ...options };
    if (!LogLevel[this.options.level])
      throw new Error('Options "level" must be one of log.LEVELS enum!');
    if (typeof this.options.maxDepth !== "number")
      throw new Error('Options "maxDepth" must be a number!');
    if (typeof this.options.maxStringLength !== "number")
      throw new Error('Options "maxStringLength" must be a number!');
    if (this.options.prefix && typeof this.options.prefix !== "string")
      throw new Error('Options "prefix" must be a string!');
    if (this.options.suffix && typeof this.options.suffix !== "string")
      throw new Error('Options "suffix" must be a string!');
    if (typeof this.options.logger !== "object")
      throw new Error('Options "logger" must be an object!');
    if (typeof this.options.data !== "object")
      throw new Error('Options "data" must be an object!');
  }
  _limitDepth(obj) {
    return limitDepth(obj, this.options.maxDepth);
  }
  getLevel() {
    return this.options.level;
  }
  setLevel(level) {
    if (!LogLevel[level])
      throw new Error('Options "level" must be one of log.LEVELS enum!');
    this.options.level = level;
  }
  internal(level, message, data, exception) {
    if (level > this.options.level)
      return;
    data = { ...this.options.data, ...data };
    data = Object.keys(data).length > 0 ? this._limitDepth(data) : void 0;
    exception = this._limitDepth(exception);
    this.options.logger.log(level, message, data, exception, {
      prefix: this.options.prefix,
      suffix: this.options.suffix
    });
  }
  setOptions(options) {
    this.options = { ...this.options, ...options };
  }
  getOptions() {
    return { ...this.options };
  }
  child(options) {
    let { prefix } = this.options;
    if (options.prefix) {
      prefix = prefix ? `${prefix}${PREFIX_DELIMITER}${options.prefix}` : options.prefix;
    }
    const data = options.data ? { ...this.options.data, ...options.data } : this.options.data;
    const newOptions = {
      ...this.options,
      ...options,
      prefix,
      data
    };
    return new Log(newOptions);
  }
  error(message, data) {
    this.internal(1 /* ERROR */, message, data);
  }
  exception(exception, message, data) {
    this.internal(1 /* ERROR */, message, data, exception);
  }
  softFail(message, data) {
    this.internal(2 /* SOFT_FAIL */, message, data);
  }
  warning(message, data) {
    this.internal(3 /* WARNING */, message, data);
  }
  info(message, data) {
    this.internal(4 /* INFO */, message, data);
  }
  debug(message, data) {
    this.internal(5 /* DEBUG */, message, data);
  }
  perf(message, data) {
    this.internal(6 /* PERF */, message, data);
  }
  warningOnce(message) {
    if (this.warningsOnceLogged.has(message))
      return;
    this.warningsOnceLogged.add(message);
    this.warning(message);
  }
  deprecated(message) {
    this.warningOnce(message);
  }
};
__name(Log, "Log");

// src/logger_json.ts
var DEFAULT_OPTIONS2 = {
  skipLevelInfo: false,
  skipTime: false
};
var LoggerJson = class extends Logger {
  constructor(options = {}) {
    super({ ...DEFAULT_OPTIONS2, ...options });
  }
  _log(level, message, data, exception, opts = {}) {
    const { prefix, suffix } = opts;
    if (exception)
      data = { ...data, exception };
    if (prefix)
      message = `${prefix}${PREFIX_DELIMITER} ${message}`;
    if (suffix)
      message = `${message} ${suffix}`;
    const rec = {
      time: !this.options.skipTime ? new Date() : void 0,
      level: this.options.skipLevelInfo && level === 4 /* INFO */ ? void 0 : LogLevel[level],
      msg: message,
      ...data
    };
    const line = JSON.stringify(rec);
    this._outputWithConsole(level, line);
    return line;
  }
};
__name(LoggerJson, "LoggerJson");

// src/index.ts
var log = new Log();
var src_default = log;
export {
  LEVELS,
  LEVEL_TO_STRING,
  Log,
  LogLevel,
  Logger,
  LoggerJson,
  LoggerText,
  PREFIX_DELIMITER,
  src_default as default,
  getLevelFromEnv,
  limitDepth,
  truncate
};
//# sourceMappingURL=index.mjs.map